# =============================================================================
# DEPLOY SERVER WORKFLOW
# =============================================================================
#
# PURPOSE:
#   Automatically build and deploy the server to AWS when server code changes.
#
# AUTHENTICATION:
#   This workflow uses AWS OIDC (OpenID Connect) for secure, keyless authentication.
#   OIDC is more secure than long-lived access keys because:
#   - No permanent credentials stored in GitHub Secrets
#   - Short-lived tokens generated at workflow runtime
#   - Automatic rotation without manual intervention
#
# SETUP REQUIRED:
#   To enable OIDC authentication, you need to configure AWS:
#
#   Step 1: Create GitHub OIDC Provider in AWS
#     1. Go to AWS Console → IAM → Identity providers
#     2. Click "Add provider"
#     3. Provider type: OpenID Connect
#     4. Provider URL: https://token.actions.githubusercontent.com
#     5. Audience: sts.amazonaws.com
#     6. Click "Add provider"
#
#   Step 2: Create IAM Role for GitHub Actions
#     1. Go to AWS Console → IAM → Roles
#     2. Click "Create role"
#     3. Trusted entity type: Web identity
#     4. Identity provider: token.actions.githubusercontent.com
#     5. Audience: sts.amazonaws.com
#     6. GitHub organization: your-org (or username for personal repos)
#     7. GitHub repository: your-repo (optional, for tighter security)
#     8. Attach policies needed for deployment:
#        - AmazonEC2ContainerRegistryFullAccess
#        - AmazonECS_FullAccess
#        - Custom policy for Terraform state (S3 + DynamoDB)
#     9. Name the role (e.g., "GitHubActionsDeployRole")
#     10. Copy the Role ARN
#
#   Step 3: Add Role ARN as GitHub Secret
#     1. Go to repository Settings → Secrets and variables → Actions
#     2. Click "New repository secret"
#     3. Name: AWS_DEPLOY_ROLE_ARN
#     4. Value: arn:aws:iam::ACCOUNT_ID:role/GitHubActionsDeployRole
#     5. Click "Add secret"
#
#   Step 4: (Optional) Remove old access keys
#     Once OIDC is working, you can delete AWS_ACCESS_KEY_ID and
#     AWS_SECRET_ACCESS_KEY secrets for improved security.
#
# FALLBACK:
#   If AWS_DEPLOY_ROLE_ARN is not configured, this workflow will fall back to
#   using AWS_ACCESS_KEY_ID and AWS_SECRET_ACCESS_KEY. This is less secure
#   and should be migrated to OIDC when possible.
#
# =============================================================================

name: Deploy Server

on:
  push:
    branches: [ "main" ]
    paths:
      - 'server/**'
      - 'gradle/**'
      - 'build.gradle.kts'
      - '.github/workflows/deploy-server.yml'

jobs:
  deploy:
    name: Build and Deploy
    runs-on: ubuntu-latest
    timeout-minutes: 30
    permissions:
      id-token: write # Required for OIDC authentication
      contents: read

    steps:
    - uses: actions/checkout@v4

    - uses: ./.github/actions/setup-java-gradle

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3

    # =========================================================================
    # AWS Authentication
    # =========================================================================
    # Prefer OIDC (role-to-assume) over access keys for better security.
    # Falls back to access keys if OIDC role is not configured.
    - name: Configure AWS Credentials (OIDC)
      if: ${{ secrets.AWS_DEPLOY_ROLE_ARN != '' }}
      uses: aws-actions/configure-aws-credentials@v4
      with:
        role-to-assume: ${{ secrets.AWS_DEPLOY_ROLE_ARN }}
        aws-region: us-west-1

    - name: Configure AWS Credentials (Access Keys - Fallback)
      if: ${{ secrets.AWS_DEPLOY_ROLE_ARN == '' }}
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: us-west-1

    - name: Terraform Init
      working-directory: server/terraform
      env:
        TF_STATE_BUCKET: ${{ secrets.TF_STATE_BUCKET }}
        TF_LOCK_TABLE: ${{ secrets.TF_LOCK_TABLE }}
        TF_STATE_KEY: server/terraform.tfstate
        TF_STATE_REGION: us-west-1
      run: |
        terraform init \
          -backend-config="bucket=${TF_STATE_BUCKET}" \
          -backend-config="key=${TF_STATE_KEY}" \
          -backend-config="region=${TF_STATE_REGION}" \
          -backend-config="dynamodb_table=${TF_LOCK_TABLE}" \
          -backend-config="encrypt=true"

    - name: Terraform Apply
      working-directory: server/terraform
      run: terraform apply -auto-approve

    - name: Get ECR Repo URL
      id: tf-outputs
      working-directory: server/terraform
      run: |
        echo "ECR_URL=$(terraform output -raw ecr_repository_url)" >> $GITHUB_OUTPUT

    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2

    - name: Build and Push Container (Jib)
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        ECR_USERNAME: ${{ steps.login-ecr.outputs.username }}
        ECR_PASSWORD: ${{ steps.login-ecr.outputs.password }}
        ECR_REPO_URL: ${{ steps.tf-outputs.outputs.ECR_URL }}
      run: |
        ./gradlew :server:app:jibDockerBuild \
          -Djib.to.image=$ECR_REPO_URL \
          --stacktrace --info

        docker push $ECR_REPO_URL:latest

    - name: Force ECS Deployment
      run: |
        aws ecs update-service --cluster battery-butler-cluster --service battery-butler-service --force-new-deployment
