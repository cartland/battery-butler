# =============================================================================
# SERVER BUILD & DEPLOY TO DEV
# =============================================================================
#
# PURPOSE:
#   Build the server container on push to main and auto-deploy to dev environment.
#   Images are tagged with the git SHA for traceability.
#
# FLOW:
#   Push to main → Build Image → Tag with SHA → Push to ECR → Deploy to Dev
#
# The same SHA can then be promoted to staging and prod via manual workflows.
#
# =============================================================================

name: Server Build & Deploy (Dev)

on:
  push:
    branches: [ "main" ]
    tags-ignore:
      - '**'
    paths:
      - 'server/**'
      - 'gradle/**'
      - 'build.gradle.kts'
      - '.github/workflows/server-build.yml'

env:
  AWS_REGION: us-west-1

jobs:
  # ===========================================================================
  # Pre-check: Verify AWS credentials are configured
  # ===========================================================================
  check-credentials:
    name: Check AWS Credentials
    runs-on: ubuntu-latest
    outputs:
      has-credentials: ${{ steps.check.outputs.has-credentials }}
    steps:
      - name: Check for AWS credentials
        id: check
        run: |
          if [ -n "${{ secrets.AWS_DEPLOY_ROLE_ARN }}" ] || [ -n "${{ secrets.AWS_ACCESS_KEY_ID }}" ]; then
            echo "has-credentials=true" >> $GITHUB_OUTPUT
          else
            echo "has-credentials=false" >> $GITHUB_OUTPUT
            echo "::warning::AWS credentials not configured. See deploy-server.yml for setup."
          fi

  # ===========================================================================
  # Build & Push Container
  # ===========================================================================
  build:
    name: Build Container
    needs: check-credentials
    if: needs.check-credentials.outputs.has-credentials == 'true'
    runs-on: ubuntu-latest
    timeout-minutes: 20
    permissions:
      id-token: write
      contents: read
    outputs:
      image-tag: ${{ steps.meta.outputs.sha }}
      ecr-url: ${{ steps.tf-outputs.outputs.ECR_URL }}
    env:
      USE_OIDC: ${{ secrets.AWS_DEPLOY_ROLE_ARN != '' }}

    steps:
    - uses: actions/checkout@v6

    - uses: ./.github/actions/setup-java-gradle

    - name: Image metadata
      id: meta
      run: |
        SHA="${{ github.sha }}"
        SHORT_SHA="${SHA:0:7}"
        echo "sha=$SHORT_SHA" >> $GITHUB_OUTPUT
        echo "full-sha=$SHA" >> $GITHUB_OUTPUT
        echo "Building image with tag: $SHORT_SHA"

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3

    - name: Configure AWS Credentials (OIDC)
      if: env.USE_OIDC == 'true'
      uses: aws-actions/configure-aws-credentials@v5
      with:
        role-to-assume: ${{ secrets.AWS_DEPLOY_ROLE_ARN }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Configure AWS Credentials (Access Keys)
      if: env.USE_OIDC != 'true'
      uses: aws-actions/configure-aws-credentials@v5
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    # Initialize Terraform just to get ECR URL (shared across envs)
    - name: Terraform Init (Dev)
      working-directory: server/terraform
      env:
        TF_STATE_BUCKET: ${{ secrets.TF_STATE_BUCKET }}
        TF_LOCK_TABLE: ${{ secrets.TF_LOCK_TABLE }}
      run: |
        terraform init \
          -backend-config="bucket=${TF_STATE_BUCKET}" \
          -backend-config="key=server/dev/terraform.tfstate" \
          -backend-config="region=${{ env.AWS_REGION }}" \
          -backend-config="dynamodb_table=${TF_LOCK_TABLE}" \
          -backend-config="encrypt=true"

    - name: Get ECR URL
      id: tf-outputs
      working-directory: server/terraform
      run: |
        # Get ECR URL - it may not exist yet on first run
        # Use -json to avoid ANSI escape codes in output
        OUTPUT_JSON=$(terraform output -json 2>/dev/null || echo "{}")
        if echo "$OUTPUT_JSON" | jq -e '.ecr_repository_url.value' > /dev/null 2>&1; then
          ECR_URL=$(echo "$OUTPUT_JSON" | jq -r '.ecr_repository_url.value')
          echo "ECR_URL=$ECR_URL" >> $GITHUB_OUTPUT
        else
          echo "ECR not yet provisioned, will be created during apply"
          echo "ECR_URL=pending" >> $GITHUB_OUTPUT
        fi

    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2

    - name: Build Container (Jib)
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        IMAGE_TAG: ${{ steps.meta.outputs.sha }}
      run: |
        # Build with Jib - outputs to local Docker daemon
        ./gradlew :server:app:jibDockerBuild \
          -Djib.to.image=${ECR_REGISTRY}/battery-butler-server:${IMAGE_TAG} \
          --stacktrace

    - name: Push Container to ECR
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        IMAGE_TAG: ${{ steps.meta.outputs.sha }}
      run: |
        # Push with SHA tag
        docker push ${ECR_REGISTRY}/battery-butler-server:${IMAGE_TAG}

        # Also tag as latest-dev for easy reference
        docker tag ${ECR_REGISTRY}/battery-butler-server:${IMAGE_TAG} \
                   ${ECR_REGISTRY}/battery-butler-server:latest-dev
        docker push ${ECR_REGISTRY}/battery-butler-server:latest-dev

        echo "Pushed image: ${ECR_REGISTRY}/battery-butler-server:${IMAGE_TAG}"

  # ===========================================================================
  # Deploy to Dev
  # ===========================================================================
  deploy-dev:
    name: Deploy to Dev
    needs: build
    runs-on: ubuntu-latest
    timeout-minutes: 15
    environment: dev
    permissions:
      id-token: write
      contents: read
    env:
      USE_OIDC: ${{ secrets.AWS_DEPLOY_ROLE_ARN != '' }}

    steps:
    - uses: actions/checkout@v6

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3

    - name: Configure AWS Credentials (OIDC)
      if: env.USE_OIDC == 'true'
      uses: aws-actions/configure-aws-credentials@v5
      with:
        role-to-assume: ${{ secrets.AWS_DEPLOY_ROLE_ARN }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Configure AWS Credentials (Access Keys)
      if: env.USE_OIDC != 'true'
      uses: aws-actions/configure-aws-credentials@v5
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Terraform Init
      working-directory: server/terraform
      env:
        TF_STATE_BUCKET: ${{ secrets.TF_STATE_BUCKET }}
        TF_LOCK_TABLE: ${{ secrets.TF_LOCK_TABLE }}
      run: |
        terraform init \
          -backend-config="bucket=${TF_STATE_BUCKET}" \
          -backend-config="key=server/dev/terraform.tfstate" \
          -backend-config="region=${{ env.AWS_REGION }}" \
          -backend-config="dynamodb_table=${TF_LOCK_TABLE}" \
          -backend-config="encrypt=true"

    - name: Terraform Apply
      working-directory: server/terraform
      run: |
        terraform apply -auto-approve \
          -var-file=environments/dev.tfvars \
          -var="image_tag=${{ needs.build.outputs.image-tag }}"

    - name: Force ECS Deployment
      run: |
        aws ecs update-service \
          --cluster battery-butler-dev-cluster \
          --service battery-butler-dev-service \
          --force-new-deployment

    - name: Wait for Deployment
      run: |
        echo "Waiting for ECS service to stabilize..."
        aws ecs wait services-stable \
          --cluster battery-butler-dev-cluster \
          --services battery-butler-dev-service
        echo "Dev deployment complete!"

    - name: Deployment Summary
      run: |
        echo "## Dev Deployment Complete" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "- **Image Tag:** ${{ needs.build.outputs.image-tag }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Commit:** ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### Promote to Staging" >> $GITHUB_STEP_SUMMARY
        echo "To deploy this image to staging, run:" >> $GITHUB_STEP_SUMMARY
        echo '```' >> $GITHUB_STEP_SUMMARY
        echo "gh workflow run server-deploy-staging.yml -f image_tag=${{ needs.build.outputs.image-tag }}" >> $GITHUB_STEP_SUMMARY
        echo '```' >> $GITHUB_STEP_SUMMARY
