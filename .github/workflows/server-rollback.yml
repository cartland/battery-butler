# =============================================================================
# SERVER ROLLBACK
# =============================================================================
#
# PURPOSE:
#   Emergency rollback to a previous image without full Terraform cycle.
#   Updates only the ECS task definition to use a previous known-good image.
#
# USAGE:
#   gh workflow run server-rollback.yml -f environment=prod -f image_tag=abc1234
#
# NOTE:
#   This performs a quick ECS-only rollback. Infrastructure changes require
#   the full deploy workflow.
#
# =============================================================================

name: Server Rollback

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to rollback'
        required: true
        type: choice
        options:
          - dev
          - staging
          - prod
      image_tag:
        description: 'Previous image tag to rollback to'
        required: true
        type: string

env:
  AWS_REGION: us-west-1

jobs:
  rollback:
    name: Rollback ${{ inputs.environment }}
    runs-on: ubuntu-latest
    timeout-minutes: 10
    environment: ${{ inputs.environment }}
    permissions:
      id-token: write
      contents: read
    env:
      USE_OIDC: ${{ secrets.AWS_DEPLOY_ROLE_ARN != '' }}
      CLUSTER_NAME: battery-butler-${{ inputs.environment }}-cluster
      SERVICE_NAME: battery-butler-${{ inputs.environment }}-service

    steps:
    - name: Configure AWS Credentials (OIDC)
      if: env.USE_OIDC == 'true'
      uses: aws-actions/configure-aws-credentials@v5
      with:
        role-to-assume: ${{ secrets.AWS_DEPLOY_ROLE_ARN }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Configure AWS Credentials (Access Keys)
      if: env.USE_OIDC != 'true'
      uses: aws-actions/configure-aws-credentials@v5
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Verify Image Exists
      run: |
        if aws ecr describe-images \
          --repository-name battery-butler-server \
          --image-ids imageTag=${{ inputs.image_tag }} > /dev/null 2>&1; then
          echo "Image verified: ${{ inputs.image_tag }}"
        else
          echo "::error::Image not found: ${{ inputs.image_tag }}"
          echo "Available tags:"
          aws ecr describe-images \
            --repository-name battery-butler-server \
            --query 'imageDetails[*].imageTags' \
            --output text | tr '\t' '\n' | head -10
          exit 1
        fi

    - name: Get Current Task Definition
      id: current
      run: |
        TASK_DEF=$(aws ecs describe-services \
          --cluster ${{ env.CLUSTER_NAME }} \
          --services ${{ env.SERVICE_NAME }} \
          --query 'services[0].taskDefinition' \
          --output text)

        echo "Current task definition: $TASK_DEF"
        echo "task-def=$TASK_DEF" >> $GITHUB_OUTPUT

        # Extract current image
        CURRENT_IMAGE=$(aws ecs describe-task-definition \
          --task-definition $TASK_DEF \
          --query 'taskDefinition.containerDefinitions[0].image' \
          --output text)
        echo "Current image: $CURRENT_IMAGE"

    - name: Create New Task Definition
      id: new-task
      run: |
        ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
        NEW_IMAGE="${ACCOUNT_ID}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/battery-butler-server:${{ inputs.image_tag }}"

        # Get current task definition and update image
        aws ecs describe-task-definition \
          --task-definition ${{ steps.current.outputs.task-def }} \
          --query 'taskDefinition' > task-def.json

        # Update the image in container definitions
        jq --arg IMAGE "$NEW_IMAGE" \
          '.containerDefinitions[0].image = $IMAGE |
           del(.taskDefinitionArn, .revision, .status, .requiresAttributes, .compatibilities, .registeredAt, .registeredBy)' \
          task-def.json > new-task-def.json

        # Register new task definition
        NEW_TASK_DEF=$(aws ecs register-task-definition \
          --cli-input-json file://new-task-def.json \
          --query 'taskDefinition.taskDefinitionArn' \
          --output text)

        echo "New task definition: $NEW_TASK_DEF"
        echo "task-def=$NEW_TASK_DEF" >> $GITHUB_OUTPUT

    - name: Update ECS Service
      run: |
        aws ecs update-service \
          --cluster ${{ env.CLUSTER_NAME }} \
          --service ${{ env.SERVICE_NAME }} \
          --task-definition ${{ steps.new-task.outputs.task-def }} \
          --force-new-deployment

    - name: Wait for Deployment
      run: |
        echo "Waiting for rollback to complete..."
        aws ecs wait services-stable \
          --cluster ${{ env.CLUSTER_NAME }} \
          --services ${{ env.SERVICE_NAME }}
        echo "Rollback complete!"

    - name: Rollback Summary
      run: |
        echo "## Rollback Complete" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "- **Environment:** ${{ inputs.environment }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Rolled back to:** ${{ inputs.image_tag }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Triggered by:** ${{ github.actor }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Time:** $(date -u +"%Y-%m-%d %H:%M:%S UTC")" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### Post-Rollback" >> $GITHUB_STEP_SUMMARY
        echo "1. Investigate the issue with the previous deployment" >> $GITHUB_STEP_SUMMARY
        echo "2. Fix and deploy a new version via normal workflow" >> $GITHUB_STEP_SUMMARY
        echo "3. Update Terraform state if needed (run full deploy workflow)" >> $GITHUB_STEP_SUMMARY
